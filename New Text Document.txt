<details>
  <summary><h1>▶ ⭐C++ programming language</h1></summary>

<details>
  <summary><h2>Class</h2></summary>
	
### Class là gì?
- Class là một cấu trúc dữ liệu , nó bao gồm thuộc tính và hành vi của đối tượng
- Object là 1 đối tượng có thuộc tính và hành vi được tạo ra từ class
- Biến trong class gọi là `PROPERTY`.
- Hàm trong class gọi là `METHOD`.
- Ví dụ:

```C++
class ClassName {
private:   
// Các thành phần riêng tư (private) chỉ có thể truy cập bên trong lớp   
// Dữ liệu thành viên, hàm thành viên, ...
protected:    
// Các thành phần bảo vệ (protected) tương tự như private, nhưng có thể truy cập từ lớp kế thừa
public:
    // Các thành phần công khai (public) được truy cập từ bên ngoài lớp
	// Dữ liệu thành viên, hàm thành viên, ...
	// Hàm thành viên và các phương thức khác có thể được định nghĩa tại đây
	// ..
};

```
**Constructor**
-  Constructor là một phương thức trong lớp (class) dùng để khởi tạo đối tượng.. 
-  Constructor được gọi tự động khi một đối tượng của lớp được tạo.
- Đặc điểm của Constructor:
	- Nếu không định nghĩa Constructor, trình biên dịch sẽ tự động tạo ra một Constructor mặc định.
	- Tên trùng với tên lớ
	- Không có kiểu trả về
	- Tự động gọi khi khởi tạo đối tượng.
	- Có thể có tham số:

-  Có hai loại chính:
	+ Constructor mặc định: Hệ thống sẽ tự động tạo
	+ Constructor với tham số :Cho phép truyền giá trị khi khởi tạo đối tượng.
	+ Constructor sao chép :Được sử dụng để khởi tạo một đối tượng mới từ một đối tượng hiện có.

<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>

class HinhChuNhat {
public:
    double chieuDai;
    double chieuRong;

    // Parameterized Constructor
    HinhChuNhat(int dai = 5, int rong = 3) {
        chieuDai = dai;
        chieuRong = rong;
    }

    // Hàm tính diện tích
    double tinhDienTich() {
        return chieuDai * chieuRong;
    }
};

int main() {
    // Tạo đối tượng HinhChuNhat và sử dụng constructor với giá trị mặc định
    HinhChuNhat hinhCN1;

    // Tạo đối tượng HinhChuNhat và truyền giá trị khác cho constructor
    HinhChuNhat hinhCN2(7, 4);

    // Hiển thị diện tích của hình chữ nhật 1 và 2
    std::cout << "Dien tich hinh chieuDai1: " << hinhCN1.tinhDienTich() << std::endl;
    std::cout << "Dien tich hinh chieuDai2: " << hinhCN2.tinhDienTich() << std::endl;

    return 0;
}


```
</details>

**copy Constructor**
- Trong C++ có hai loại copy được tạo bởi hàm xây dựng đó là:
	+ Shallow copy
		+ Chỉ sao chép địa chỉ bên trong , không sao chép dữ liệu 
		+ Khi một đối tượng bị hủy, dữ liệu chung sẽ bị giải phóng, làm cho đối tượng còn lại trỏ tới vùng nhớ không hợp lệ

	+ Deep copp
		+ Tạo một bản sao độc lập của tất cả dữ liệu ,có vùng nhớ riêng
	

<details>
<summary>Ví dụ:</summary>

```c++
#include <iostream>

using namespace std;

class TestShallowCopy {
    int a;
    int b;
    int *p;

public:
    TestShallowCopy() {
        p = new int;
    }

    TestShallowCopy(const TestShallowCopy &t) {
        a = t.a;
        b = t.b;
        p = new int; // Cấp phát vùng nhớ mới
        *p = *(t.p); // Sao chép giá trị của *p từ đối tượng gốc sang đối tượng mới
    }

    ~TestShallowCopy() {
        delete p; // Giải phóng bộ nhớ khi đối tượng bị hủy
    }

    void TaoDuLieu(int x, int y, int z) {
        a = x;
        b = y;
        *p = z;
    }

    void HienThi() {
        cout << "   Gia tri cua a la: " << a << endl;
        cout << "   Gia tri cua b la: " << b << endl;
        cout << "   Gia tri cua *p la: " << *p << endl;
    }
};

int main() {
    TestShallowCopy t1;
    t1.TaoDuLieu(2, 6, 8);
    TestShallowCopy t2 = t1;
    cout << "Du lieu cua doi tuong t1: " << endl;
    t1.HienThi();
    cout << "Du lieu cua doi tuong t2: " << endl;
    t2.HienThi();
    return 0;
}




```













</details>





**Destructor**
- là một phương thức trong lớp (class) được sử dụng để giải phóng tài nguyên
- Destructor sẽ có tên trùng với tên của class và thêm ký tự ~ ở phía trước tên.
- Không có tham số
- Chỉ có duy nhất một hàm hủy trong một lớp. Hàm hủy tự động được gọi. Nếu như chúng ta không định nghĩa hàm hủy thì mặc định trình biên dịch sẽ tự tạo ra một hàm hủy mặc nhiên
- Hàm hủy (Destructor) trong C++ được gọi tự động khi:
	+ Kết thúc hàm
	+ Kết thúc chương trình
	+ Toán tử delete được gọi
- 1 chương trình có nhiều  Constructor nhưng chỉ có 1 Destructor

<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>  
using namespace std;  
class NhanVien  {  
   public:  
        NhanVien() {    
            cout << "Ham xay dung duoc goi" << endl;    
        }    
        ~NhanVien() {    
            cout << "Ham huy duoc goi" << endl;    
        }  
};  
int main(void) {  
	NhanVien* n0 = new NhanVien();
	delete n0;
    NhanVien n1;   
    NhanVien n2; 
    return 0;  
}

```
</details>

**Vitual Destructor**

- virtual destructor nằm ở lớp cha( lớp cơ sở ), khi ta có 1 đối tượng của lớp con được tạo ra và xóa từ con trỏ của lớp cha.Destructor của cả lớp con  và lớp cha đều được gọi, đảm bảo rằng tất cả các tài nguyên được giải phóng đúng đắn.
- Khi nào cần sử dụng Virtual Destructor?
	- Khi bạn làm việc với đa hình (polymorphism).
<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>

class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor" << std::endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor" << std::endl;
    }
};

int main() {
    Base* ptr = new Derived(); // Tạo một đối tượng Derived và gán con trỏ của lớp cơ sở
    delete ptr; // Xóa đối tượng thông qua con trỏ của lớp cơ sở

    return 0;
}


```
</details>

**Static keyword:property**
- Static data member là một biến thành viên của lớp, nhưng không thuộc về bất kỳ đối tượng cụ thể nào.
- Thay vào đó, static property được chia sẻ giữa tất cả các đối tượng của lớp.
- Chỉ tồn tại một bản sao duy nhất của static property trong bộ nhớ
- Static property được khởi tạo ngoài lớp 
- Có thể được truy cập thông qua tên lớp hoặc đối tượng.
-  Ví dụ Đếm số lượng đối tượng được tạo từ một lớp
 

<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>  
class HinhChuNhat {

public:
    double chieuDai;
    double chieuRong;
    static int var;
};

int HinhChuNhat::var;

int main()
{
    HinhChuNhat hinh1;
    HinhChuNhat hinh2;
    HinhChuNhat hinh3;

	hinh1.var =10;
	// thì hinh2.var cũng bằng 10;
  

    


    return 0;
}


```
</details>


- Biến đếm chung, đếm object

<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>

class ObjectCounter {
public:
    static int count;  // Biến tĩnh để đếm số đối tượng

    ObjectCounter() {
        count++;  // Tăng biến đếm khi tạo một đối tượng mới
    }
};

int ObjectCounter::count = 0;  // Khởi tạo biến tĩnh

int main() {
    ObjectCounter obj1;  // Tạo đối tượng thứ nhất, count = 1
    ObjectCounter obj2;  // Tạo đối tượng thứ hai, count = 2

    std::cout << "Number of objects: " << ObjectCounter::count << std::endl;  // In ra số lượng đối tượng: 2
    return 0;
}

// nếu không dùng từ khóa static thì obj1 và obj2 có biến count riêng  không ảnh hưởng đến nhau.

```
</details>



**Static keyword:method**
- Static method trong C++ là một method khai báo với từ khóa static
- Không cần tạo đối tượng để gọi static method, có thể gọi thông qua tên lớp
- Static method chỉ có thể truy cập static property hoặc static method khác.

<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>

class MathUtils {
public:
    static int square(int x) {
        return x * x;
    }
};

int main() {
    int result = MathUtils::square(5);  // Gọi phương thức tĩnh mà không cần đối tượng
    std::cout << "Square of 5: " << result << std::endl;  // Output: Square of 5: 25
    return 0;
}

```

</details>


**Con trỏ this trong C++**
- This là một con trỏ đặc biệt dùng để trỏ đến địa chỉ của đối tượng hiện tại
- Khi nào nên dùng con trỏ this:
	+ Khi một đối tượng gọi một hàm thành viên, this trỏ đến đối tượng đó.
	+ phân biệt giữa biến thành viên và tham số(Nếu trùng tên)
	+ Static method không thể sử dụng con trỏ this vì static method không gắn với bất kỳ đối tượng nào.

```c++
void setData(int msnv, string ten, int tuoi) {  
    this->msnv = msnv;    
    this->ten = ten;    
    this->tuoi = tuoi; 
}
```


<details>
<summary>Ví dụ:</summary>

```c++
#include <iostream>  
using namespace std;  
class NhanVien { 
    int msnv;    
    string ten;
    int tuoi;
    public:  
       void setData(int msnv, string ten, int tuoi) {  
            this->msnv = msnv;    
            this->ten = ten;    
            this->tuoi = tuoi; 
       }    
       void showData() {
            cout << "Ten nhan vien: " << this->ten << endl;
            cout << "Ma so nhan vien: " << this->msnv << endl;
            cout << "Tuoi: " << this->tuoi << endl;
       }    
};

int main() { 
    // Nhan vien 1
    NhanVien n1;
    n1.setData(111231, "Nguyen Van A", 24);
    n1.showData();    
     
    // Nhan vien 2
    NhanVien n2 =  NhanVien();
    n2.setData(111232, "Nguyen Van B", 25);
    n2.showData();
    return 0;  
}

```

</details>



<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>

class MyClass {
public:
    void printAddress() {
        std::cout << "Address of current object: " << this << std::endl;
    }
};

int main() {
    MyClass obj1;
    MyClass obj2;
    obj1.printAddress(); // In địa chỉ của đối tượng obj1
    obj2.printAddress(); // In địa chỉ của đối tượng obj2
    return 0;
}



```

</details>




<details>
<summary>Ví dụ:</summary>

```C++
class sinhvien {
	puplic:// phạm vi truy cập
	string ten;//PROPERTY
	int tuoi;
	int mssv;
	void display(){//METHOD
	count<<"ten:"<<ten<<endl;
	count<<"tuoi:"<<tuoi<<endl;
	count<<"mssv:"<<mssv<<endl;

}
};

int main(){
	sinhvien sv1;
	sv1.ten ="hoang";//OBJECT thuộc class sinh viên
	sv1.tuoi=19;
	sv1.mssv =123123;
	sv1.display();// in ra 0.
	return 0;

}

```
- Class có thể khởi tạo giá trị ban đầu:
```C++
class sinhvien {
	puplic:// phạm vi truy cập
	sinhvien(string l_ten , int l_tuoi,string l_lop, int l_ngay){// gia tri ban đầu có tham số đầu vào
		static int  s_mssv;
		mssv=s_mssv;
		s_mssv ++;
		tuoi =l_tuoi;
		ten=l_ten;
		lop=l_lop;
		ngay =l_ngay;
	}
	string ten;//PROPERTY
	stactic int ngay; // static trong class phải khởi tạo giá trị ban đầu 
	int tuoi;
	int mssv;
	string lop;
	string ten;
	void display();//METHOD
	
	//director là 1 cơ chế tự động 
	~sinhvien(){
		count<<"Huy object co ten:"<<ten>>endl;
	}
};

int sinhvien::ngay;// khởi tạo gia trị ban đầu cho static

void sinhvien::display{
	count<<"ten:"<<ten<<endl;
	count<<"tuoi:"<<tuoi<<endl;
	count<<"mssv:"<<mssv<<endl;
	ount<<"lop:"<<mssv<<endl;

}
void test1(){
	sinhvien sv1("thai",19,"CDEE"),sv2("tha",20,"fhsjd",14);//sv1 là OBJECT thuộc class sinhvien
	printf("dia chi sv1.mssv: %p\n",&(sv1.mssv));//khác địa chỉ
	printf("dia chi sv2.mssv: %p\n",&(sv2.mssv));//khác địa chỉ
	printf("--------------");
	printf("dia chi sv1.ngay: %p\n",&(sv1.ngay));//cung  địa chỉ
	printf("dia chi sv2.ngay: %p\n",&(sv2.ngay));//cung địa chỉ
	// Khi khởi tạo thì địa chỉ của nó tồn tại trong suốt chương trình nên member static này của các object sẽ đều có cùng 1 địa chỉ.
	sv1.display();
	sv2.display();	
}

int main(){
	test1();
	return 0;
	// sẽ in ra là ten,tuoi,mssv,lop,Huy object co ten thai
}
```

</details>
</details>














<details>
  <summary><h2>Smart Pointer</h2></summary>

**Cấp phát động trong C++**
- new và delete là hai toán tử quan trọng trong C++ được sử dụng để cấp phát và giải phóng bộ nhớ động, tương ứng

```C++
int *ptr = new int; // cấp phát bộ nhớ cho một biến kiểu int
int *arr = new int[5]; // cấp phát bộ nhớ cho một mảng kiểu int với 5 phần tử

delete ptr; // giải phóng bộ nhớ của biến động
delete[] arr; // giải phóng bộ nhớ của mảng động


```
**Smart Pointer C++**
- smart pointers là một cơ chế quản lý bộ nhớ tự động.
- Memory Leak: là hiện tượng xảy ra khi một chương trình không thể giải phóng bộ nhớ đã cấp phát dẫn đến sự chậm trễ và giảm hiệu suất của chương trình 
	+ Quên giải phóng bộ nhớ
	+ Mất điều kiện để giải phóng: Các tham chiếu vòng (circular references)

**Unique Pointer**
- Chỉ có một smart pointer duy nhất được sở hữu tài nguyên tại một thời điểm.
- Không thể sao chép (copy), chỉ có thể chuyển nhượng quyền sở hữu bằng cách dùng std::move.
```C++
#include <iostream>
#include <memory>

void func() {
    std::unique_ptr<int> uniquePtr(new int(42));
    // uniquePtr sẽ tự động giải phóng vùng nhớ khi ra khỏi hàm func()
}

int main() {
    func();
    // uniquePtr đã bị giải phóng khi ra khỏi hàm func()
    return 0;
}

```
**shared_ptr**
- Chia sẻ quyền sở hữu của một tài nguyên giữa nhiều shared_ptr.
- Bộ đếm tham chiếu (reference count) được duy trì để theo dõi số lượng shared_ptr sở hữu tài nguyên.
- Tài nguyên được giải phóng khi bộ đếm tham chiếu bằng 0 (không còn shared_ptr nào sở hữu).


```C++
#include <iostream>
#include <memory>

int main() {
    // Khởi tạo một biến int x với giá trị 42
    int x = 42;

    // Tạo ba shared_ptr để trỏ đến biến int x
    std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(x);
    std::shared_ptr<int> sharedPtr2 = sharedPtr1;
    std::shared_ptr<int> sharedPtr3 = sharedPtr1;

    // In ra địa chỉ của x và số lượng tham chiếu của mỗi shared_ptr
    std::cout << "Địa chỉ của x: " << &x << std::endl;
    std::cout << "sharedPtr1: " << sharedPtr1.use_count() << std::endl;
    std::cout << "sharedPtr2: " << sharedPtr2.use_count() << std::endl;
    std::cout << "sharedPtr3: " << sharedPtr3.use_count() << std::endl;

    return 0;
}


```

**weak_ptr**
- weak_ptr không sở hữu đối tượng, chỉ giám sát đối tượng do shared_ptr quản lý.
- Muốn sd weak_ptr phải chuyển weak_ptr thành shared_ptr bằng lock, bạm thời tăng ref count của đối tượng.
- lock() sẽ trả về nullptr.Nếu đối tượng bị hủy
- Trước khi sử dụng tài nguyên, cần chuyển weak_ptr thành shared_ptr bằng lock().
**Lặp tham chiếu**
- xảy ra khi hai hoặc nhiều đối tượng trỏ qua lại lẫn nhau bằng shared_ptr
- bộ đếm tham chiếu của chúng sẽ luôn lớn hơn 0 .Do đó, tài nguyên sẽ không bao giờ được giải phóng.
- Object A có một shared_ptr quản lý để đảm bảo sự tồn tại của nó.
- Object A có một shared_ptr trỏ đến Object B, làm tăng ref count của Object B.
- Object B giữ một weak_ptr trỏ ngược lại Object A, giúp tránh vòng lặp tham chiếu.

<details>
<summary>Ví dụ:</summary>

```C++
#include <memory>
#include <iostream>
class B; // Forward declaration to use in A
class A {
public:
    std::shared_ptr<B> ptrB; // A uses shared_ptr to reference B
};
class A; // Forward declaration to use in B
class B {
public:
    std::weak_ptr<A> ptrA; // B uses weak_ptr to reference A
};

class A;
class B;
int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();
    a->ptrB = b; // A references B using shared_ptr
    b->ptrA = a; // B references A using weak_ptr
    // When main ends, a and b will be automatically released safely
    return 0;
}


```
 

</details>

<details>
<summary>Ví dụ:</summary>

```C++
std::shared_ptr<A> a_shared = ptrA.lock();
if (a_shared) {
    // Thực hiện các thao tác với a_shared ở đây
    std::cout << "Process A successful!" << std::endl;
} else {
    std::cout << "A is no longer available." << std::endl;
}

```

-  lock() trên một std::weak_ptr, nếu đối tượng mà weak_ptr đang theo dõi vẫn tồn tại , lock() sẽ trả về một std::shared_ptr hợp lệ trỏ đến đối tượng đó. Điều này có nghĩa là bạn có thể sử dụng shared_ptr này để truy cập và thao tác với đối tượng an toàn.
- Nếu A vẫn tồn tại, ptrA.lock() sẽ trả về một shared_ptr<A> hợp lệ (a_shared), và bạn có thể sử dụng a_shared để thực hiện các thao tác như thông báo "Process A successful!". Ngược lại, nếu A đã bị hủy, ptrA.lock() sẽ trả về một shared_ptr<A> rỗng, và bạn sẽ nhận được thông báo "A is no longer available."
- lock():Giúp đảm bảo rằng bạn chỉ truy cập vào đối tượng khi nó vẫn còn tồn tại, tránh gây ra lỗi truy cập vào bộ nhớ đã giải phóng.



</details>
</details>
<details>
  <summary><h2>namespace</h2></summary>

- Namespace:là từ khóa trong C++ được sử dụng để phân biệt các hàm, lớp, biến cùng tên trong các file khác nhau.
 tạo những vùng nhớ khác nhau ,mỗi namespace là 1 chương trình riêng ,Nhưng trong 1 namespace không thể có 2 biến cùng tên
- using namespace std ,cho phép sử dụng các thành phần trong namespace std, mà không cần phải ghi rõ std::cout,cin 
<details>
<summary>Ví dụ:</summary>

```C++
//fileB.hpp

#include <iostream>

using namespace std;

namespace fileB{
    void function(() { cout << “function in fileB running.” << endl; }
}
//fileC.hpp
#include <iostream>

using namespace std;

namespace fileC{
    void function(() { cout << “function in fileC running.” endl; }
}


# 

```
**Dùng using namespace tên, có thể rút gọn code**
- Ví dụ:
```C++
using namespace onga;
int main(){
	cout<<"con ong a: teo"<<teo<<endl;
	return 0;
	
}

// FILE MAIN.CPP
#include <iostream>
#incldue “fileB.hpp”
#include “fileC.hpp”

using namespace std;

int main() {
    fileB::function();
    fileC::function();
    
    return 0;
}

 

```

</details>
</details>
<details>
  <summary><h2>Lambda,templates</h2></summary>

**Lambda**
- Lambda là một cú pháp trong ngôn ngữ lập trình C++ cho phép tạo ra các hàm vô danh (anonymous functions) ngắn gọn và linh hoạt ngay tại chỗ mà không cần phải đặt tên  cho chúng,Cú pháp của lambda rất linh hoạt và có thể được sử dụng để viết mã ngắn gọn và dễ đọc.
- Cú pháp :
` [capture clause] (parameter list) -> return type { body }`
- Capture clause: Là cách bạn chọn để capture các biến từ phạm vi bên ngoài vào bên trong lambda. Có thể capture bằng reference (&), capture bằng giá trị (=), hoặc không capture ([]).
- parameter list: Là danh sách các tham số của hàm lambda, tương tự như danh sách tham số của một hàm thông thường.
- return type: Là kiểu dữ liệu của giá trị trả về của hàm lambda. Trong một số trường hợp, trình biên dịch có thể tự suy luận kiểu dữ liệu này.
- body: Là phần thân của hàm lambda, nơi  viết mã lệnh thực thi các công việc của hàm.
- Trong C++, có ba cách chính để capture các biến từ phạm vi bên ngoài vào trong một lambda function:
	+	Capture bằng Giá Trị (=):
		+ Capture tất cả các biến được sử dụng trong lambda theo cách sao chép giá trị của chúng.
		Các biến được capture bằng giá trị sẽ không thay đổi giá trị của chúng ngoài lambda khi chúng được thay đổi trong lambda.
	+	Capture bằng Reference (&):
		+ Capture tất cả các biến được sử dụng trong lambda theo cách tham chiếu đến chúng.
		+ Các biến được capture bằng reference cho phép thay đổi giá trị của chúng ngoài lambda khi chúng được thay đổi trong lambda.
	+ Capture Tự Do (không sử dụng capture clause):
		+ Không capture bất kỳ biến nào từ phạm vi bên ngoài vào trong lambda.
		+ Lambda chỉ có thể truy cập các biến được định nghĩa trong lambda hoặc các biến toàn cục.
**Lambda function mang lại tính ngắn gọn và linh hoạt trong việc viết code, giúp tăng cường độ dễ đọc và dễ bảo trì của chương trình**

**Template**
- Là một kiểu dữ liệu trừu tượng tổng quát hóa cho các kiểu dữ liệu int, float, double, bool...cho phép  viết mã một cách tổng quát cho nhiều loại dữ liệu khác nhau mà không cần phải viết lại mã nhiều lần
- Có 2 loại  Templates:
	+ Class Templates: 
		+ Cho phép tạo một lớp chung để làm việc với nhiều loại dữ liệu khác nhau mà không cần viết lại mã lập trình cho mỗi loại dữ liệu đó. 
		+ Khi sử dụng một template class, bạn cần cung cấp các loại dữ liệu cụ thể cho các tham số khi khai báo đối tượng từ template
	+ Function templates:Function templates cho phép bạn tạo ra các hàm mà có thể làm việc với nhiều kiểu dữ liệu khác nhau. chỉ cần viết một hàm mẫu (template) và sau đó sử dụng nó để tạo ra các phiên bản cụ thể cho mỗi kiểu dữ liệu mà bạn muốn sử dụng.
	+ Variadic Templates là một tính năng trong C++ ,Tạo một hàm với số lượng tham số đầu vào không xác định.
	
```C++
	// Khai báo một class template cho một cặp giá trị
#include <iostream>

// Định nghĩa một class template
template <typename T>
class Box {
public:
    T value; // Thành viên dữ liệu kiểu T

    // Constructor để khởi tạo giá trị
    Box(T v) : value(v) {}
};

int main() {
    // Tạo các đối tượng của Box với các kiểu dữ liệu khác nhau
    Box<int> intBox(123); // Đối tượng Box với kiểu int
    Box<double> doubleBox(45.67); // Đối tượng Box với kiểu double
    Box<std::string> stringBox("Hello, World!"); // Đối tượng Box với kiểu std::string

    // In ra giá trị của các đối tượng Box
    std::cout << "Giá trị của intBox: " << intBox.value << std::endl; // 123
    std::cout << "Giá trị của doubleBox: " << doubleBox.value << std::endl; // 45.67
    std::cout << "Giá trị của stringBox: " << stringBox.value << std::endl; // Hello, World!

    return 0;
}










	// Hàm template tính tổng của hai giá trị
	template <class T>
	T sum(T a, T b) {
		return a + b;
	}
	int main() {
    std::cout << "Sum of integers: " << sum(5, 10) << std::endl; // T được suy luận là int
    std::cout << "Sum of doubles: " << sum(3.14, 2.5) << std::endl; // T được suy luận là double
    

    return 0;
}

```
	

**Virtual Function**
- Hàm ảo , cho phép hàm của lớp con ghi đè lên hàm lớp cha






</details>
<details>
<summary><h3>Hướng đối tượng </h3></summary>

### hướng đối tượng là gi?
- OOP là một phương pháp lập trình dưới dạng các "đối tượng," mỗi đối tượng có chứa dữ liệu và các phương thức để thao tác dữ liệu đó.
- Các khái niệm quan trọng trong OOP bao gồm:
	+ Class: để tạo ra các đối tượng , nó mô tả dữ liệu và phương thức của đối tượng đó
	+ Đối tượng (Object) : Một đối tượng cụ thể được tạo ra từ class, có 
**Phạm vi truy cập:**
- Public:Member nào trong Public thì có thể truy cập từ mọi nơi trong chương trình , bao gồm object của lớp và từ các lớp khác thông qua method của lớp đó, có thể truy cập được
- protected:Member trong protected thì method của Class con và method trong class có thể truy cập
- private: Chỉ có method  trong class có thể truy cập .

```c++
#include <iostream>

class ClassA {
public:
    int publicVarA;

    ClassA() : publicVarA(0) {}
};

class ClassB {
public:
    void accessPublicVar(ClassA &objA) {
        std::cout << "Value of publicVarA from ClassB: " << objA.publicVarA << std::endl;
    }
};

int main() {
    ClassA objA;
    ClassB objB;

    objA.publicVarA = 42; // Gán giá trị cho thành viên publicVarA của đối tượng objA

    objB.accessPublicVar(objA); // Truy cập thành viên publicVarA của đối tượng objA từ đối tượng objB

    return 0;
}






```

**1/Encapsulation (Tính đóng gói):**
- PROPERTY phải nằm ở private hoặc protected.
- Lý do để bảo vệ dữ liệu của một đối tượng khỏi sự xâm phạm từ bên ngoài.

<details>
<summary>Ví dụ:</summary>

```C++
#include<iostream>
#include<string>
using namespace std;
class doituong{
	private:
	int tuoi;//PROPERTY
	string ten;

	public:
	void hienthi(){//hienthi() method
	    cout<<"ten: "<<ten<<endl;
		cout<<"tuoi: "<<tuoi<<endl;
	}
	void setten(int name){
		ten=name;
	}
	void settuoi(int old){
		tuoi=old;
	}
	int gettuoi(){
		return tuoi;

	}
	string getten(){
		return ten;

	}
	

}
int main(){
	doituong dt;//dt là object thuộc class doituong
	dt.hienthi();
	return 0;
 }
```
</details>

**2/Inheritance (Tính kế thừa ):**
- 1 class được kế thừa property và method của một class khác
- Class con có thể kế thừa property và method của class cha trong phạm vi public và protected  
- Có 3 kiểu kế thừa là public, private và protected. Những property và method được kế thừa từ class cha sẽ nằm ở quyền truy cập của class con tương ứng với kiểu kế thừa.
- Nên dùng: Khi một lớp B được miêu tả là "B là một A". Ví dụ: một lớp hình tròn có thể kế thừa từ một lớp hình học.
- Không nên:Mối quan hệ "has-a" (có một) diễn ra khi một lớp chứa một đối tượng của một lớp khác. ví dụ: danhsachSV chứa một đối tượng sinhvien, do đó chúng ta có thể nói danhsachSV "có" hoặc "bao gồm" danh sách các sinh viên.

<details>
<summary>Ví dụ:</summary>

```C++
using namespace std;

class doituong{

	protected:
	int namsinh;
	string ten;
	int tuoi;
	public:
	void nhapthongtin(string name,int old,int year){ 
	    	ten=name;
			tuoi=old;
			namsinh=year;
	}
	void hienthi(){//hienthi() method cha
	    	cout<<"ten: "<<ten<<endl;
			cout<<"tuoi: "<<tuoi<<endl;
			cout<<"namsinh: "<<namsinh<<endl;
	}

};

class sinhvien : public doituong{
    protected:
	int MSSV;
	public:
	void setMSSV(int mssv){
		MSSV=mssv;
	}
	void hienthi(){// là method con từ cha và sửa nó thì được gọi là override(ghi đè)
		cout<<"MSSV: "<<MSSV<<endl;
		cout<<"ten: "<<ten<<endl;
		cout<<"tuoi: "<<tuoi<<endl;
		cout<<"namsinh: "<<namsinh<<endl;
		

	}

};


class HS : public sinhvien{
    private:
	int HS;
	public:
	void setHS(int hs){
		HS=hs;
	}
	void hienthi();

};
//thằng HS sẽ kế thừa thằng gần nhất >> hienthi(), sẽ kế thừa hienthi() của sinhvien chứ không phải doituong
int main(void){
    doituong dt;
	sinhvien sv;
	dt.nhapthongtin("hung",24,1883);
	dt.hienthi();
	printf("-----------\n");
	sv.nhapthongtin("thai",25,1992);
	sv.hienthi();

    return 0;
}
//ten: hung
//tuoi: 24
//namsinh: 1883
-----------
//MSSV: 0
//ten: thai
//tuoi: 25
//namsinh: 1992

```
</details>


<details>
<summary>Ví dụ:</summary>

```C++
class doituong{
	protected:
	int namsinh;
	string ten;
	int tuoi;
	public:
	void nhapthongtin(string name,int old,int year){ 
	    	ten=name;
			tuoi=old;
			namsinh=year;
	}

};

class sinhvien : private doituong{	
	// tất cả property  của doituong sẽ chuyển vào private của sinhvien
 

};

class hs : private sinhvien{
 // lỗi vì thằng private không kế thừa và sử dụng được từ class con
};

```

</details>

**3/Polymorphism (Tính đa hình):**

- Function overloading :Các method có thể trùng tên với nhau , nhưng phải khác các input parameter
- Function overoverriding : Lớp con Ghi đè lên hàm của lớp cha.
- Để ghi đè đúng cách, hàm trong lớp cơ sở nên được khai báo với từ khóa virtual.
<details>
<summary>Ví dụ:</summary>

```C++
using namespace std;

class ToanHoc {
public:
    void tong(int a, int b) {
        cout << "Tong a + b: " << a + b << endl;
    }

    void hienthi(int a, int b, int c) {
        cout << "Tong a + b + c: " << a + b + c << endl;
    }

    void hienthi(int a, double b) {
        cout << "Tong a + b : " << a + b << endl;
    }
};

int main() {
    ToanHoc th;
    th.tong(7, 4);
    th.hienthi(1,2,3);
    th.hienthi(1,1.1);
     

    return 0;
}
```
</details>

**4/Abstraction (Tính trừu tượng ):**

- Chỉ cung cấp giao diện, ẩn đi chi tiết triển khai.
- Ví dụ tính phương trình bậc 2 , để tính nghiệm x1,x2 thì ta có hàm tính detal = b * b - 4 * a * c .delta là 1 trong những thành phần tạo ra kết quả.Vậy thì hàm tính delta này phải được ẩn đi bằng cách để nó vào phạm vi private

<details>
<summary>Ví dụ:</summary>

```C++
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

class GiaiPhuongTrinh
{
private:
    double a;
    double b;
    double c;
    double x1;
    double x2;
    double delta;

    void tinhNghiem()
    {
        delta = b * b - 4 * a * c;
        if (delta < 0)
        {
            delta = -1;
        }
        else if (delta == 0)
        {
            x1 = x2 = -b / (2 * a);
        }
        else if (delta > 0)
        {
            x1 = (-b + sqrt(delta)) / (2 * a);
            x2 = (-b - sqrt(delta)) / (2 * a);
        }
    }

public:
    void enterNumber(double num_a, double num_b, double num_c);
    void printResult();
};

void GiaiPhuongTrinh::enterNumber(double num_a, double num_b, double num_c)
{
    a = num_a;
    b = num_b;
    c = num_c;
}

void GiaiPhuongTrinh::printResult()
{
    tinhNghiem();
    if (delta == -1)
    {
        cout << "PT vo nghiem" << endl;
    }
    else if (delta == 0)
    {
        cout << "PT co nghiem chung: " << x1 << endl;
    }
    else if (delta > 0)
    {
        cout << "PT co 2 nghiem: \n";
        cout << "x1: " << x1 << endl;
        cout << "x2: " << x2 << endl;
    }
}

int main()
{
    GiaiPhuongTrinh phuongtrinh1;
    phuongtrinh1.enterNumber(1, 5, 4);
    phuongtrinh1.printResult();

    return 0;
}





```


</details>

**Hàm Bạn,Lớp Bạn?**
- Là các khái niệm cho phép một hàm hoặc một lớp khác có thể truy cập các thành viên private hoặc protected của một lớp.

**Template trong C++ là gì?**

- Là một kiểu dữ liệu trừu tượng tổng quát hóa cho các kiểu dữ liệu int, float, double, bool...
- Có 2 loại  Templates:
	+ Class Templates: cho phép proberti và method trong Class có kiểu dữ liệu template
	+ Function templates:cho phép viết một hàm với kiểu dữ liêu template , kiểu template sẽ tổng quát hóa nhiều kiểu dữ liệu khác, làm mã ngắn gọn hơn mà không cần triển khai lại hàm với kiểu dữ liệu cụ thể
		- Ví dụ 1 hàm có tham số truyền vào là int , int thì ta phải viết 1 hàm có cùng kiểu dữ liệu đó , nhưng nếu viết hàm dùng kiểu dữ liêu template, thì không cần quan tâm đến thông số truyền vào là kiểu dữ liệu gì

<details>
<summary>Ví dụ</summary>

```C++	
void hienthi(int a,int b ,int c){ 
		printf("tong a+b+c :%d\n",a+b+c);
}
int hienthi(int a,double b){ 		
		return a +(int)b;
}
//thay vì dài như vậy ta có thể dùng Template do C++ hỗ trợ
//Code viết lại:
template <typename test>
test tong(test a,test b){
	return test(a +b);
}
int main(void){
	tong("tong a va b: %d\n",tong(6,4));
	tong("tong a va b: %f\n",tong(6.5,4.4));
} 
```
</details>


**Virtual funtion trong C++ là gì?**
- Được sử dụng để tạo hàm ảo. Hàm ảo cho phép lớp con ghi đè hàm của lớp cha  .


</details>
<details>
  <summary><h2>Standard template library </h2></summary>

## STL là một thư viện trong ngôn ngữ lập trình C++ cung cấp một tập hợp các  hàm mẫu và thuật toán để lưu trữ và thao tác dữ liệu.

**Một số thành phần chính của STL:**
- Container(Bộ chứa) :là các cấu trúc dữ liệu được sử dụng để lưu trữ các phần tử.
- Iterator: Cung cấp 1 cách chung để duyệt các phần tử trong Container mà không cần quan tâm tới container đó là gi.
- Kết hợp với các thuật toán STL (std::sort, std::find, std::for_each) để thực hiện các thao tác như sắp xếp, tìm kiếm, và lọc dữ liệu.
 - Trong STL, có nhiều loại iterators:
	+ Input Iterators: Cho phép duyệt qua các phần tử của một container từ đầu đến cuối, nhưng không thể thay đổi giá trị của các phần tử.
	+ Output Iterators: Cho phép ghi dữ liệu vào một container từ đầu đến cuối.
- Algorithms: STL cung cấp một loạt các thuật toán tiêu chuẩn như sort, find, binary_search, etc. Những thuật toán này có thể được áp dụng trên các containers.

**Vector trong C++ là gì?**

- vector là một container cung cấp một mảng động ,có thể thay đổi kích thước 
- có thể chèn và xóa phần tử ở cuối mảng một cách hiệu quả. 
- Không chèn xóa ở đầu , vì phải di chuyển các phần tử còn lại về phía trước > tốn time so với các loại khác
- Nó khác mảng động ở chỗ là quản lý bộ nhớ tự động 
- Sử dụng Vector: 
	+ Thêm hoặc xóa phần tử ở cuối danh sách
	+ Cần truy cập ngẫu nhiên  thông qua chỉ số.
![image](https://github.com/user-attachments/assets/fb20cb53-317f-4f83-a4db-e971372f2c6a)


**List là gì**
- List là một danh sách liên kết hai chiều.
- trong đó mỗi phần tử là một nút chứa:
	+ Giá trị dữ liệu.
	+ Con trỏ trỏ tới phần tử trước và sau nó.
- Không hỗ trợ truy cập ngẫu nhiên	
- Sử dụng list khi:
	+ Thực hiện nhiều thao tác chèn/xóa ở bất kỳ vị trí nào trong danh sách.
	+ Cần thực hiện nhiều thao tác chèn/xóa mà không làm ảnh hưởng đến các iterators hiện có.
**Deque là gì**
- là một container cho phép thêm/xóa ở cả hai đầu và truy cập ngẫu nhiên.(như Vector)
**Map trong C++ là gì?**
- dùng để lưu trữ các cặp khóa-giá trị (key-value pairs).
- Mỗi khóa là duy nhất và được sử dụng để truy cập giá trị tương ứng. 
- Các phần tử được sắp xếp theo khóa, không cần thao tác sắp xếp thủ công.
- truy cập dữ liệu thông qua khóa, giúp tổ chức và quản lý dữ liệu dễ dàng hơn.
- Ví dụ:Lưu trữ thông tin cá nhân theo ID.
**Multimap  trong C++ là gì?**
1. Khóa trùng lặp: nhiều giá trị cho cùng khóa 
2. Sắp xếp: Các phần tử được sắp xếp tự động theo thứ tự của khóa.
**Unordered_map  trong C++ là gì?**
1. Không cho phép khóa trùng lặp; mỗi khóa phải duy nhất.
2. Sắp xếp: Không có thứ tự sắp xếp giữa các phần tử.
**unordered_multimap  trong C++ là gì?**
1. Khóa trùng lặp: nhiều giá trị cho cùng khóa 
2.  Không có thứ tự sắp xếp giữa các phần tử.

 

**set**
- Set: Là một container không cho phép phần tử trùng lặp và sắp xếp tự động các phần tử theo thứ tự tăng dần
- Khi cần sắp xếp tự động các phần tử theo thứ tự tăng dần hoặc giảm dần.
- Khi cần lưu trữ một tập hợp các phần tử duy nhất.
- Hiệu suất:Tìm kiếm, chèn, xóa
**Multiset set:**
1. Cho phép phần tử trùng lặp.
2. Các phần tử trong multiset có thứ tự mặc định theo thứ tự tăng dần
 
**Unordered_set:**
1. Không cho phép phần tử trùng lặp.
2. Sắp xếp: Không duy trì thứ tự sắp xếp.

**unordered_multiset**
1. Cho phép phần tử trùng lặp.
2. Không duy trì thứ tự sắp xếp.
**stack**
1. Nguyên tắc hoạt động LIFO  (Last In, First Out).
2. Thêm/xóa  tại đỉnh ngăn xếp.
**queue**
1. Nguyên tắc hoạt động FIFO (First In, First Out).
2. Thêm ở cuối hàng đợi, xóa ở đầu hàng đợi.
# Iterator
- Iterator cung cấp một cách chung để duyệt qua các phần tử của một container mà không cần biết chi tiết về cách container được triển khai.
- Iterator là một đối tượng cho phép truy cập tuần tự qua các phần tử của một container.
- Iterator thường được sử dụng bằng cách sử dụng toán tử * để truy cập giá trị của iterator hiện tại và toán tử ++ để di chuyển đến phần tử tiếp theo trong cấu trúc dữ liệu
- Nó giống như con trỏ, cho phép di chuyển qua các phần tử trong container.

# Algorithm
- Thư viện STL (Standard Template Library) cung cấp một số thuật toán tiêu biểu thông qua algorithm. 
- Các thuật toán này hoạt động trên các phạm vi hoặc các loại dữ liệu khác nhau, giúp thực hiện các nhiệm vụ như sắp xếp, tìm kiếm, chuyển đổi dữ liệu, và nhiều thao tác khác. 












</details>
<details>
  <summary><h2>Multithreading</h2></summary>

**Lập trình đa luồng (Multithreading):**
- Tiến trình (process) trong lập trình là một chương trình đang được thực thi
- một đơn vị thực thi độc lập trong một chương trình
- Là việc sử dụng nhiều luồng đồng thời trong một chương trình để tăng hiệu suất và sử dụng tốt các tài nguyên hệ thống.Muốn sử dụng thì `#include <thread>`

- Các vấn đề thường gặp trong đa luồng:
-	Data race: Nhiều luồng truy cập và ghi dữ liệu cùng lúc mà không có đồng bộ.
	+ Dùng mutex, lock_guard, atomic operations để tránh
-	Deadlock: Các luồng chờ nhau giải phóng tài nguyên, dẫn đến tình trạng chờ vĩnh viễn.
	+ Dùng lock 
	+ Sử dụng Timeout:Thiết lập thời gian chờ khi yêu cầu tài nguyên. 
	+ Sử dụng Hierarchical Locking (Khóa theo cấp bậc): 
		+ Đảm bảo rằng các luồng đều tuân thủ thứ tự khóa giống nhau (khóa dữ liệu 1 trước, sau đó khóa dữ liệu 2 sau).
		+ Thread A cố gắng khóa khóa dữ liệu 1. Nếu  dữ liệu 1 đang trống, nó sẽ khóa thành công và tiếp tục.
		+ Thread A sau đó cố gắng khóa dữ liệu 2. Nếu  dữ liệu 2 đang trống, nó sẽ khóa thành công. Nếu không, nó sẽ chờ cho đến khi  dữ liệu 2 được mở khóa.

-   Race condition: Xảy ra khi các luồng không có thứ tự logic khi tranh chấp tài nguyên
	+ Sử dụng cờ đồng bộ hoặc điều kiện chờ như std::condition_variable


**Synchronization Mechanisms (Cơ chế đồng bộ hóa):**
- Đồng bộ hóa: Là quá trình đảm bảo rằng các luồng hoạt động đồng bộ khi truy cập và thay đổi dữ liệu chia sẻ. 
- Cơ chế đồng bộ hóa: Là phương pháp được sử dụng để đạt được đồng bộ  giữa các luồng, bao gồm cơ chế locks,unlock,mutex.Muốn sử dụng cơ chế này thì `#include <mutex>`
- Mutex (Mutual Exclusion): được sử dụng để đồng bộ hóa truy cập vào các tài nguyên được chia sẻ giữa các luồng
- Để khóa một mutex, bạn cần sử dụng phương thức lock() của đối tượng mutex, và để mở khóa mutex, bạn sử dụng phương thức unlock(). 
- Cơ chế lock(),unlock() được sử dụng để khóa mutex.Việc khóa mutex trước và mở khóa mutex sau đảm bảo rằng chỉ có một luồng có thể truy cập vào dữ liệu chia sẽ giữa 2 luồng
- std::unique_lock: Cơ bản có tính năng giống lock(),unlock(). nghĩa là 1 thời điểm chỉ cho 1 luồng truy cập dữ liệu , nhưng việc unlock là tự động
- std::shared_lock:cho phép nhiều luồng đọc cùng một lúc.




**Concurrent Data Structures (Cấu trúc dữ liệu đồng thời)**
- Cấu trúc dữ liệu đồng thời: Là  cấu trúc hỗ trợ truy cập  dữ liệu từ nhiều luồng mà không cần sử dụng locks hoặc mutexes.
- condition_variable là  một cơ chế trong C++11 được sử dụng để đồng bộ hóa các luồng thông qua việc chờ đợi và thông báo về sự kiện xảy ra
- condition_variable cho phép một hoặc nhiều luồng chờ đợi cho một điều kiện nhất định trở thành đúng trước khi tiếp tục thực hiện công việc của mình.
- condition_variable có các hàm :notify_one(),notify_all(),wait().Chúng sẽ tự động mở khóa mutexz


**Bất đồng bộ (Asynchronous):**
- Trong lập trình, bất đồng bộ thường ám chỉ việc thực hiện một tác vụ mà không cần chờ đợi kết quả của tác vụ trước đó hoàn thành.
- notify_one() nằm trong thread1 ,wait() nằm trong thread2.Điều này đảm bảo rằng khi điều kiện được thỏa mãn trong thread1, thread2 sẽ được thông báo và tỉnh dậy để tiếp tục thực thi.
- Khi điều kiện thread 1 thõa mãn , thì wait() sẽ tự unlock tài nguyên , để các luồng khác có thể tiếp tục thực thi



- Starvation (Thiếu tài nguyên):   
	+ xảy ra khi một hoặc nhiều luồng không thể truy cập tài nguyên cần thiết để tiếp tục thực thi, vì các luồng khác liên tục chiếm dụng tài nguyên đó.
	+ Condition Variables để điều khiển thứ tự thực thi của các luồng và đảm bảo rằng tất cả các luồng đều có cơ hội thực thi.
	+ thiết lập giới hạn thời gian chờ cho các tài nguyên để đảm bảo rằng không có luồng nào bị chặn quá lâu.


